# System for quickly and painlessly provisioning Couchbase Server virtual machines across multiple Couchbase versions and OS's.
# See README.md for usage instructions

begin

# Collect the names of the working directory and its parent (os and cb version)
OPERATING_SYSTEM = File.basename(Dir.getwd)
VERSION  = File.basename(File.expand_path('..'))

# Variable declarations are in this file
load '../../settings.rb'

### DO NOT EDIT BELOW THIS LINE

# Number of nodes to provision
unless ENV['VAGRANT_NODES'].nil? || ENV['VAGRANT_NODES'] == 0
  num_nodes = ENV['VAGRANT_NODES'].to_i
else
  if num_nodes.nil?
    num_nodes = DEFAULT_NUMBER_OF_NODES
  end
end

unless ENV['VAGRANT_CPUS'].nil? || ENV['VAGRANT_CPUS'] == 0
  num_cpus = ENV['VAGRANT_CPUS'].to_i
else
  num_cpus = DEFAULT_NUMBER_OF_CPUS
end

unless ENV['VAGRANT_RAM'].nil? || ENV['VAGRANT_RAM'] == 0
  ram_in_MB = ENV['VAGRANT_RAM'].to_i
else
  ram_in_MB = DEFAULT_RAM_IN_MB
end

unless ENV['VAGRANT_VPN'].nil?
  vpn = "on"
else
  vpn = "off"
end

# Check to see if a custom download location has been given, if not use a default value (2.5.0 style)
if COUCHBASE_DOWNLOAD_LINKS.has_key?(VERSION)
  if COUCHBASE_DOWNLOAD_LINKS[VERSION].is_a?(String)
    url = COUCHBASE_DOWNLOAD_LINKS[VERSION]
  elsif COUCHBASE_DOWNLOAD_LINKS[VERSION].has_key?(OPERATING_SYSTEM)
    url = COUCHBASE_DOWNLOAD_LINKS[VERSION][OPERATING_SYSTEM]
  end
elsif COUCHBASE_DOWNLOAD_LINKS.has_key?(OPERATING_SYSTEM)
  url = COUCHBASE_DOWNLOAD_LINKS[OPERATING_SYSTEM]
end
url ||= COUCHBASE_DOWNLOAD_LINKS['generic']

puppet_location ||= "../.."

# Check to see if a custom ip address has been given, if not generate one
if (defined?(ip)).nil?
  ip_address = "10." + String(IP_ADDRESSES[OPERATING_SYSTEM]) + "." + String(IP_ADDRESSES[VERSION]) + ".10%d"
end

# Generate a hostname template
hostname = "#{VERSION.gsub '.', ''}-#{OPERATING_SYSTEM}.vagrants"
if hostname =~ /^[0-9]/
  hostname.prepend("cb")
end
hostname.prepend("node%d-")

# Check to see if the vagrant command given was 'up', if so print a handy dialogue
if ARGV[0] == "up" && !ARGV[1]
  puts "\e[32m=== Upping #{num_nodes} node(s) on #{OPERATING_SYSTEM} and cb version #{VERSION} ==="
end

### Start the vagrant configuration ###
Vagrant.configure("2") do |config|

  # Define VM properties for each node (for both virtualbox and
  # libvirt providers).
  config.vm.provider :virtualbox do |vb|
    vb.memory = ram_in_MB
    vb.cpus = num_cpus
    vb.customize ["modifyvm", :id, "--ioapic", "on"]
    vb.customize ["modifyvm", :id, "--natdnshostresolver1", "#{vpn}"]
    vb.linked_clone = true if Vagrant::VERSION >= "1.8.0"
    vb.destroy_unused_network_interfaces = true
  end
  config.vm.provider :libvirt do |libvirt|
    libvirt.memory = ram_in_MB
    libvirt.cpus = num_cpus
  end

  config.vm.synced_folder ENV['HOME'], "/vmhost_home/"

  # Define the vagrant box download location
  if !(VAGRANT_BOXES[OPERATING_SYSTEM]["box_url"].nil?)
    config.vm.box_url = VAGRANT_BOXES[OPERATING_SYSTEM]["box_url"]
  end

  # Define the vagrant box name
  if !(VAGRANT_BOXES[OPERATING_SYSTEM]["box_name"].nil?)
    box_name = VAGRANT_BOXES[OPERATING_SYSTEM]["box_name"]
  else
    box_name = VAGRANT_BOXES[OPERATING_SYSTEM]
  end

  # Define the box version if specified - default to most recent
  if !(VAGRANT_BOXES[OPERATING_SYSTEM]["box_version"].nil?)
    boc_version = VAGRANT_BOXES[OPERATING_SYSTEM]["boc_version"]
  end

  # Check to see if the VM is not running Windows and provision with puppet
  if !(OPERATING_SYSTEM.include?("win"))
    # Provision the server itself with puppet
    config.vm.provision "puppet" do |puppet|
      puppet.manifests_path = puppet_location # Define a custom location and name for the puppet file
      puppet.manifest_file = "puppet.pp"
      puppet.facter = { # Pass variables to puppet
        "version" => VERSION, # Couchbase Server version
        "url" => url, # Couchbase download location
      }
    end
  end

  # Provision Config for each of the nodes
  1.upto(num_nodes) do |num|
    config.vm.define "node#{num}" do |node|
      node.vm.box = box_name
      if !(boc_version.nil?)
        node.vm.boc_version = boc_version
      end
      if Vagrant.has_plugin?("vagrant-cachier")
        # Configure cached packages to be shared between instances of the same base box.
        config.cache.scope = :box
      end
      if PUBLIC_LAN && USE_DHCP
        node.vm.network :public_network, :bridge => DEFAULT_BRIDGE
        puts "Public LAN ip obtained via DHCP, find it by connecting to the node: vagrant ssh node#{num}"
      elsif PUBLIC_LAN
       node.vm.network :public_network, :bridge => DEFAULT_BRIDGE, :ip =>  PUBLIC_IP_BASE % num
       puts "Public LAN ip : #{PUBLIC_IP_BASE % num}"
      else
        node.vm.network :private_network, :ip => ip_address % num
        if Vagrant.has_plugin?("landrush")
          puts "Private network (host only) : http://#{hostname % num}:8091/"
        else
          puts "Private network (host only) : http://#{ip_address % num}:8091/"
        end
      end
      node.vm.hostname = hostname % num
      node.vm.provider "virtualbox" do |v|
        v.name = "Couchbase Server #{VERSION} #{OPERATING_SYSTEM.gsub '/', '_'} Node #{num}"
        if(OPERATING_SYSTEM.include?("win")) # If the VM is running Windows it will start with a GUI
          v.gui = true
        end
      end
      if Vagrant.has_plugin?("landrush")
        node.landrush.enabled = true
        node.landrush.tld = "vagrants"
      end
      # Postfix a random value to hostname to uniquify it.
      node.vm.provider "libvirt" do |v|
        v.random_hostname = true
      end
    end
  end

  if ARGV[0] == "up" && !ARGV[1]
    if PUBLIC_LAN && USE_DHCP
      puts "\e[32m=== Upping #{num_nodes} node(s) on public LAN via DHCP ==="
    elsif PUBLIC_LAN
      puts "\e[32m=== Upping #{num_nodes} node(s) on public LAN IPs #{PUBLIC_IP_BASE.sub('%d','')}{1..#{num_nodes}} ==="
    else
      puts "\e[32m=== Upping #{num_nodes} node(s) on IPs #{ip_address.sub('%d','')}{1..#{num_nodes}} ==="
    end
  end

end
rescue
end
